labels = c(1, 2, 3),
include.lowest = TRUE)
standardized_data <- select(standardized_data, -quality)
# Train/Test Split
set.seed(123)  # Set seed for reproducibility
split_index <- createDataPartition(standardized_data$ordinal_quality, p = 0.8, list = FALSE)
train_data <- standardized_data[split_index, ]
test_data <- standardized_data[-split_index, ]
# Baseline Model
most_common_quality <- Mode(train_data$ordinal_quality)
baseline_prediction <- rep(most_common_quality, nrow(test_data))
predicted_labels_baseline <- as.integer(baseline_prediction)
true_labels <- as.integer(test_data$ordinal_quality)
# Accuracy
accuracy_baseline <- sum(predicted_labels_baseline == true_labels) / length(true_labels)
cat("Accuracy for the baseline model:", accuracy_baseline, "\n")
# Ordinal Regression
# Backward elimination for the most parsimonious model
# Non-correlated features
features_reg <- c("residual.sugar", "chlorides",
"total.sulfur.dioxide", "density", "pH", "sulphates",
"alcohol")
all_features <- setdiff(features_reg, "ordinal_quality")
# Interaction Terms
selected_features <- c(all_features, "residual.sugar*chlorides", "residual.sugar*total.sulfur.dioxide",
"residual.sugar*density", "residual.sugar*pH", "residual.sugar*sulphates",
"residual.sugar*alcohol", "chlorides*total.sulfur.dioxide",
"chlorides*density", "chlorides*pH", "chlorides*sulphates", "chlorides*alcohol",
"total.sulfur.dioxide*density", "total.sulfur.dioxide*pH",
"total.sulfur.dioxide*sulphates", "total.sulfur.dioxide*alcohol",
"density*pH", "density*sulphates", "density*alcohol", "pH*sulphates",
"pH*alcohol", "sulphates*alcohol")
best_accuracy <- 0
best_feature_set <- NULL
best_num_variables <- Inf  # Initialize with a large value
while (length(selected_features) >= 1) {
current_accuracy <- 0
current_num_variables <- length(selected_features)
worst_feature <- NULL
exit_loop <- FALSE  # Flag to control loop exit
for (feature in selected_features) {
current_features <- setdiff(selected_features, feature)
if (length(current_features) == 0) {
exit_loop <- TRUE
break  # Exit the inner loop when only one feature is left
}
# Train the model with the current set of features
formula_str <- paste("factor(ordinal_quality) ~ ", paste(current_features, collapse = "+"), sep = "")
model <- polr(as.formula(formula_str), data = train_data, Hess = TRUE)
# Predict using the trained model on the test set
# (Ensure test_data is also a data frame)
predicted_labels <- predict(model, newdata = as.data.frame(test_data))
# Convert predicted and true labels to integers (if not already)
predicted_labels <- as.integer(predicted_labels)
true_labels <- as.integer(test_data$ordinal_quality)
# Compute accuracy
accuracy <- sum(predicted_labels == true_labels) / length(true_labels)
# Update the current accuracy, worst feature, and number of variables if needed
if (accuracy > current_accuracy) {
current_accuracy <- accuracy
worst_feature <- feature
current_num_variables <- length(current_features)
}
}
if (exit_loop) {
break  # Exit the outer loop when only one feature is left
}
# Remove the worst feature from the selected features
selected_features <- setdiff(selected_features, worst_feature)
# Update the best feature set, accuracy, and number of variables if needed
if (current_accuracy > best_accuracy ||
(current_accuracy == best_accuracy && current_num_variables < best_num_variables)) {
best_accuracy <- current_accuracy
best_feature_set <- selected_features
best_num_variables <- current_num_variables
}
#cat("Selected features:", selected_features, "\n")
#cat("Current accuracy:", current_accuracy, "\n")
#cat("Current number of variables:", current_num_variables, "\n\n")
}
cat("Best feature set:", best_feature_set, "\n")
cat("Best accuracy:", best_accuracy, "\n")
cat("Best number of variables:", best_num_variables, "\n")
# Multiple Regression
initial_model <- lm(ordinal_quality ~ . + residual.sugar*chlorides +
residual.sugar*total.sulfur.dioxide +
residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
density*pH + density*sulphates + density*alcohol + pH*sulphates +
pH*alcohol + sulphates*alcohol, data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
# Multiple Regression
initial_model <- lm(ordinal_quality ~ ., data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
View(train_data)
a
initial_model <- lm(ordinal_quality ~ residual.sugar + chlorides + total.sulfur.dioxide + density+ pH +
sulphates + alcohol + residual.sugar*chlorides +
residual.sugar*total.sulfur.dioxide +
residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
density*pH + density*sulphates + density*alcohol + pH*sulphates +
pH*alcohol + sulphates*alcohol, data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
### 0-10 Target Variable
# Standardize Data
standardized_data <- as.data.frame(scale(data[, -which(names(data) == "quality")]))
standardized_data <- cbind(quality = quality_column, standardized_data)
# Train/Test Split
set.seed(123)  # Set seed for reproducibility
split_index <- createDataPartition(standardized_data$quality, p = 0.8, list = FALSE)
train_data <- standardized_data[split_index, ]
test_data <- standardized_data[-split_index, ]
# Baseline Model
most_common_quality <- Mode(train_data$quality)
baseline_prediction <- rep(most_common_quality, nrow(test_data))
predicted_labels_baseline <- as.integer(baseline_prediction)
true_labels <- as.integer(test_data$quality)
# Accuracy
accuracy_baseline <- sum(predicted_labels_baseline == true_labels) / length(true_labels)
cat("Accuracy for the baseline model:", accuracy_baseline, "\n")
# Ordinal Regression
# Backward elimination for the most parsimonious model
# Non-correlated features
features_reg <- c("residual.sugar", "chlorides",
"total.sulfur.dioxide", "density", "pH", "sulphates",
"alcohol")
all_features <- setdiff(features_reg, "quality")
# Interaction Terms
selected_features <- c(all_features, "residual.sugar*chlorides", "residual.sugar*total.sulfur.dioxide",
"residual.sugar*density", "residual.sugar*pH", "residual.sugar*sulphates",
"residual.sugar*alcohol", "chlorides*total.sulfur.dioxide",
"chlorides*density", "chlorides*pH", "chlorides*sulphates", "chlorides*alcohol",
"total.sulfur.dioxide*density", "total.sulfur.dioxide*pH",
"total.sulfur.dioxide*sulphates", "total.sulfur.dioxide*alcohol",
"density*pH", "density*sulphates", "density*alcohol", "pH*sulphates",
"pH*alcohol", "sulphates*alcohol")
best_accuracy <- 0
best_feature_set <- NULL
best_num_variables <- Inf  # Initialize with a large value
while (length(selected_features) >= 1) {
current_accuracy <- 0
current_num_variables <- length(selected_features)
worst_feature <- NULL
exit_loop <- FALSE  # Flag to control loop exit
for (feature in selected_features) {
current_features <- setdiff(selected_features, feature)
if (length(current_features) == 0) {
exit_loop <- TRUE
break  # Exit the inner loop when only one feature is left
}
# Train the model with the current set of features
formula_str <- paste("factor(quality) ~ ", paste(current_features, collapse = "+"), sep = "")
model <- polr(as.formula(formula_str), data = train_data, Hess = TRUE)
# Predict using the trained model on the test set
# (Ensure test_data is also a data frame)
predicted_labels <- predict(model, newdata = as.data.frame(test_data))
# Convert predicted and true labels to integers (if not already)
predicted_labels <- as.integer(predicted_labels)
true_labels <- as.integer(test_data$quality)
# Compute accuracy
accuracy <- sum(predicted_labels == true_labels) / length(true_labels)
# Update the current accuracy, worst feature, and number of variables if needed
if (accuracy > current_accuracy) {
current_accuracy <- accuracy
worst_feature <- feature
current_num_variables <- length(current_features)
}
}
if (exit_loop) {
break  # Exit the outer loop when only one feature is left
}
# Remove the worst feature from the selected features
selected_features <- setdiff(selected_features, worst_feature)
# Update the best feature set, accuracy, and number of variables if needed
if (current_accuracy > best_accuracy ||
(current_accuracy == best_accuracy && current_num_variables < best_num_variables)) {
best_accuracy <- current_accuracy
best_feature_set <- selected_features
best_num_variables <- current_num_variables
}
#cat("Selected features:", selected_features, "\n")
#cat("Current accuracy:", current_accuracy, "\n")
#cat("Current number of variables:", current_num_variables, "\n\n")
}
cat("Best feature set:", best_feature_set, "\n")
cat("Best accuracy:", best_accuracy, "\n")
cat("Best number of variables:", best_num_variables, "\n")
# Multiple Regression
initial_model <- lm(quality ~ residual.sugar + chlorides + total.sulfur.dioxide + density+ pH +
sulphates + alcohol + residual.sugar*chlorides +
residual.sugar*total.sulfur.dioxide +
residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
density*pH + density*sulphates + density*alcohol + pH*sulphates +
pH*alcohol + sulphates*alcohol, data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
# Display the final model
summary(final_model)
X_test <- as.data.frame(test_data[, !grepl("quality", names(test_data))])
predicted_labels <- predict(final_model, newdata = X_test)
predicted_labels <- as.integer(predicted_labels)
# Convert predicted and true labels to integers (if not already)
predicted_labels <- as.integer(predicted_labels)
true_labels <- as.integer(test_data$quality)
# Compute accuracy
accuracy <- sum(predicted_labels == true_labels) / length(true_labels)
print(accuracy)
### 1-3 Target Variable
# Standardize Data
standardized_data <- as.data.frame(scale(data[, -which(names(data) == "quality")]))
standardized_data <- cbind(quality = quality_column, standardized_data)
standardized_data$ordinal_quality <- cut(standardized_data$quality,
breaks = c(-Inf, 4.5, 5.5, Inf),
labels = c(1, 2, 3),
include.lowest = TRUE)
standardized_data <- select(standardized_data, -quality)
# Train/Test Split
set.seed(123)  # Set seed for reproducibility
split_index <- createDataPartition(standardized_data$ordinal_quality, p = 0.8, list = FALSE)
train_data <- standardized_data[split_index, ]
test_data <- standardized_data[-split_index, ]
# Baseline Model
most_common_quality <- Mode(train_data$ordinal_quality)
baseline_prediction <- rep(most_common_quality, nrow(test_data))
predicted_labels_baseline <- as.integer(baseline_prediction)
true_labels <- as.integer(test_data$ordinal_quality)
# Accuracy
accuracy_baseline <- sum(predicted_labels_baseline == true_labels) / length(true_labels)
cat("Accuracy for the baseline model:", accuracy_baseline, "\n")
# Ordinal Regression
# Backward elimination for the most parsimonious model
# Non-correlated features
features_reg <- c("residual.sugar", "chlorides",
"total.sulfur.dioxide", "density", "pH", "sulphates",
"alcohol")
all_features <- setdiff(features_reg, "ordinal_quality")
# Interaction Terms
selected_features <- c(all_features, "residual.sugar*chlorides", "residual.sugar*total.sulfur.dioxide",
"residual.sugar*density", "residual.sugar*pH", "residual.sugar*sulphates",
"residual.sugar*alcohol", "chlorides*total.sulfur.dioxide",
"chlorides*density", "chlorides*pH", "chlorides*sulphates", "chlorides*alcohol",
"total.sulfur.dioxide*density", "total.sulfur.dioxide*pH",
"total.sulfur.dioxide*sulphates", "total.sulfur.dioxide*alcohol",
"density*pH", "density*sulphates", "density*alcohol", "pH*sulphates",
"pH*alcohol", "sulphates*alcohol")
best_accuracy <- 0
best_feature_set <- NULL
best_num_variables <- Inf  # Initialize with a large value
while (length(selected_features) >= 1) {
current_accuracy <- 0
current_num_variables <- length(selected_features)
worst_feature <- NULL
exit_loop <- FALSE  # Flag to control loop exit
for (feature in selected_features) {
current_features <- setdiff(selected_features, feature)
if (length(current_features) == 0) {
exit_loop <- TRUE
break  # Exit the inner loop when only one feature is left
}
# Train the model with the current set of features
formula_str <- paste("factor(ordinal_quality) ~ ", paste(current_features, collapse = "+"), sep = "")
model <- polr(as.formula(formula_str), data = train_data, Hess = TRUE)
# Predict using the trained model on the test set
# (Ensure test_data is also a data frame)
predicted_labels <- predict(model, newdata = as.data.frame(test_data))
# Convert predicted and true labels to integers (if not already)
predicted_labels <- as.integer(predicted_labels)
true_labels <- as.integer(test_data$ordinal_quality)
# Compute accuracy
accuracy <- sum(predicted_labels == true_labels) / length(true_labels)
# Update the current accuracy, worst feature, and number of variables if needed
if (accuracy > current_accuracy) {
current_accuracy <- accuracy
worst_feature <- feature
current_num_variables <- length(current_features)
}
}
if (exit_loop) {
break  # Exit the outer loop when only one feature is left
}
# Remove the worst feature from the selected features
selected_features <- setdiff(selected_features, worst_feature)
# Update the best feature set, accuracy, and number of variables if needed
if (current_accuracy > best_accuracy ||
(current_accuracy == best_accuracy && current_num_variables < best_num_variables)) {
best_accuracy <- current_accuracy
best_feature_set <- selected_features
best_num_variables <- current_num_variables
}
#cat("Selected features:", selected_features, "\n")
#cat("Current accuracy:", current_accuracy, "\n")
#cat("Current number of variables:", current_num_variables, "\n\n")
}
cat("Best feature set:", best_feature_set, "\n")
cat("Best accuracy:", best_accuracy, "\n")
cat("Best number of variables:", best_num_variables, "\n")
# Multiple Regression
initial_model <- lm(ordinal_quality ~ residual.sugar + chlorides + total.sulfur.dioxide + density+ pH +
sulphates + alcohol + residual.sugar*chlorides +
residual.sugar*total.sulfur.dioxide +
residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
density*pH + density*sulphates + density*alcohol + pH*sulphates +
pH*alcohol + sulphates*alcohol, data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
# Multiple Regression
initial_model <- lm(ordinal_quality ~ residual.sugar + chlorides + total.sulfur.dioxide + density+ pH +
sulphates + alcohol)
# Multiple Regression
initial_model <- lm(ordinal_quality ~ residual.sugar + chlorides + total.sulfur.dioxide + density+ pH +
sulphates + alcohol,
# + residual.sugar*chlorides +
# residual.sugar*total.sulfur.dioxide +
# residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
# residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
# chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
# total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
# total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
# density*pH + density*sulphates + density*alcohol + pH*sulphates +
# pH*alcohol + sulphates*alcohol,
data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
# Multiple Regression
initial_model <- lm(ordinal_quality ~ residual.sugar + chlorides + #total.sulfur.dioxide
+ density+ pH +
sulphates + alcohol,
# + residual.sugar*chlorides +
# residual.sugar*total.sulfur.dioxide +
# residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
# residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
# chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
# total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
# total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
# density*pH + density*sulphates + density*alcohol + pH*sulphates +
# pH*alcohol + sulphates*alcohol,
data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
View(initial_model)
View(final_model)
View(standardized_data)
# Multiple Regression
initial_model <- lm(factor(ordinal_quality) ~ residual.sugar + chlorides + #total.sulfur.dioxide
+ density+ pH +
sulphates + alcohol,
# + residual.sugar*chlorides +
# residual.sugar*total.sulfur.dioxide +
# residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
# residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
# chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
# total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
# total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
# density*pH + density*sulphates + density*alcohol + pH*sulphates +
# pH*alcohol + sulphates*alcohol,
data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
### 1-3 Target Variable
# Standardize Data
standardized_data <- as.data.frame(scale(data[, -which(names(data) == "quality")]))
standardized_data <- cbind(quality = quality_column, standardized_data)
standardized_data$ordinal_quality <- cut(standardized_data$quality,
breaks = c(-Inf, 4.5, 5.5, Inf),
labels = c(1, 2, 3),
include.lowest = TRUE)
standardized_data$ordinal_quality <- as.numeric(train_data$ordinal_quality)
### 1-3 Target Variable
# Standardize Data
standardized_data <- as.data.frame(scale(data[, -which(names(data) == "quality")]))
standardized_data <- cbind(quality = quality_column, standardized_data)
standardized_data$ordinal_quality <- cut(standardized_data$quality,
breaks = c(-Inf, 4.5, 5.5, Inf),
labels = c(1, 2, 3),
include.lowest = TRUE)
standardized_data$ordinal_quality <- as.numeric(standardized_data$ordinal_quality)
standardized_data <- select(standardized_data, -quality)
# Train/Test Split
set.seed(123)  # Set seed for reproducibility
split_index <- createDataPartition(standardized_data$ordinal_quality, p = 0.8, list = FALSE)
train_data <- standardized_data[split_index, ]
test_data <- standardized_data[-split_index, ]
# Baseline Model
most_common_quality <- Mode(train_data$ordinal_quality)
baseline_prediction <- rep(most_common_quality, nrow(test_data))
predicted_labels_baseline <- as.integer(baseline_prediction)
true_labels <- as.integer(test_data$ordinal_quality)
# Accuracy
accuracy_baseline <- sum(predicted_labels_baseline == true_labels) / length(true_labels)
cat("Accuracy for the baseline model:", accuracy_baseline, "\n")
# Ordinal Regression
# Backward elimination for the most parsimonious model
# Non-correlated features
features_reg <- c("residual.sugar", "chlorides",
"total.sulfur.dioxide", "density", "pH", "sulphates",
"alcohol")
all_features <- setdiff(features_reg, "ordinal_quality")
# Interaction Terms
selected_features <- c(all_features, "residual.sugar*chlorides", "residual.sugar*total.sulfur.dioxide",
"residual.sugar*density", "residual.sugar*pH", "residual.sugar*sulphates",
"residual.sugar*alcohol", "chlorides*total.sulfur.dioxide",
"chlorides*density", "chlorides*pH", "chlorides*sulphates", "chlorides*alcohol",
"total.sulfur.dioxide*density", "total.sulfur.dioxide*pH",
"total.sulfur.dioxide*sulphates", "total.sulfur.dioxide*alcohol",
"density*pH", "density*sulphates", "density*alcohol", "pH*sulphates",
"pH*alcohol", "sulphates*alcohol")
best_accuracy <- 0
best_feature_set <- NULL
best_num_variables <- Inf  # Initialize with a large value
while (length(selected_features) >= 1) {
current_accuracy <- 0
current_num_variables <- length(selected_features)
worst_feature <- NULL
exit_loop <- FALSE  # Flag to control loop exit
for (feature in selected_features) {
current_features <- setdiff(selected_features, feature)
if (length(current_features) == 0) {
exit_loop <- TRUE
break  # Exit the inner loop when only one feature is left
}
# Train the model with the current set of features
formula_str <- paste("factor(ordinal_quality) ~ ", paste(current_features, collapse = "+"), sep = "")
model <- polr(as.formula(formula_str), data = train_data, Hess = TRUE)
# Predict using the trained model on the test set
# (Ensure test_data is also a data frame)
predicted_labels <- predict(model, newdata = as.data.frame(test_data))
# Convert predicted and true labels to integers (if not already)
predicted_labels <- as.integer(predicted_labels)
true_labels <- as.integer(test_data$ordinal_quality)
# Compute accuracy
accuracy <- sum(predicted_labels == true_labels) / length(true_labels)
# Update the current accuracy, worst feature, and number of variables if needed
if (accuracy > current_accuracy) {
current_accuracy <- accuracy
worst_feature <- feature
current_num_variables <- length(current_features)
}
}
if (exit_loop) {
break  # Exit the outer loop when only one feature is left
}
# Remove the worst feature from the selected features
selected_features <- setdiff(selected_features, worst_feature)
# Update the best feature set, accuracy, and number of variables if needed
if (current_accuracy > best_accuracy ||
(current_accuracy == best_accuracy && current_num_variables < best_num_variables)) {
best_accuracy <- current_accuracy
best_feature_set <- selected_features
best_num_variables <- current_num_variables
}
#cat("Selected features:", selected_features, "\n")
#cat("Current accuracy:", current_accuracy, "\n")
#cat("Current number of variables:", current_num_variables, "\n\n")
}
cat("Best feature set:", best_feature_set, "\n")
cat("Best accuracy:", best_accuracy, "\n")
cat("Best number of variables:", best_num_variables, "\n")
# Multiple Regression
initial_model <- lm(ordinal_quality ~ residual.sugar + chlorides + total.sulfur.dioxide
+ density+ pH +
sulphates + alcohol,
+ residual.sugar*chlorides +
residual.sugar*total.sulfur.dioxide +
residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
density*pH + density*sulphates + density*alcohol + pH*sulphates +
pH*alcohol + sulphates*alcohol, data = train_data)
# Multiple Regression
initial_model <- lm(ordinal_quality ~ residual.sugar + chlorides + total.sulfur.dioxide +
density+ pH + sulphates + alcohol + residual.sugar*chlorides +
residual.sugar*total.sulfur.dioxide +
residual.sugar*density + residual.sugar*pH + residual.sugar*sulphates +
residual.sugar*alcohol + chlorides*total.sulfur.dioxide +
chlorides*density + chlorides*pH + chlorides*sulphates + chlorides*alcohol +
total.sulfur.dioxide*density + total.sulfur.dioxide*pH +
total.sulfur.dioxide*sulphates + total.sulfur.dioxide*alcohol +
density*pH + density*sulphates + density*alcohol + pH*sulphates +
pH*alcohol + sulphates*alcohol, data = train_data)
# Perform backward elimination using stepwise regression
final_model <- step(initial_model, direction = "backward")
# Display the final model
summary(final_model)
X_test <- as.data.frame(test_data[, !grepl("ordinal_quality", names(test_data))])
predicted_labels <- predict(final_model, newdata = X_test)
predicted_labels <- as.integer(predicted_labels)
# Convert predicted and true labels to integers (if not already)
predicted_labels <- as.integer(predicted_labels)
true_labels <- as.integer(test_data$ordinal_quality)
# Compute accuracy
accuracy <- sum(predicted_labels == true_labels) / length(true_labels)
print(accuracy)
